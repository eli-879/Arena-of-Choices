/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/character.js":
/*!**************************!*\
  !*** ./src/character.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Character)\n/* harmony export */ });\nclass Character {\r\n\tconstructor(gameWidth, gameHeight, name, pos, id, assets, ctx) {\r\n\t\tthis.gameHeight = gameHeight;\r\n\t\tthis.gameWidth = gameWidth;\r\n\t\tthis.id = id;\r\n\r\n\t\t// character visuals\r\n\t\tthis.height = 80;\r\n\t\tthis.width = 80;\r\n\t\tthis.name = name;\r\n\t\tthis.nameLength = ctx.measureText(this.name);\r\n\t\tthis.image;\r\n\t\tthis.imageWinning;\r\n\t\tthis.imageTimer = 0;\r\n\t\tthis.imageTimerMax = 125;\r\n\t\tthis.border = 0;\r\n\t\tthis.spacing = 0;\r\n\t\tthis.row = 2;\r\n\t\tthis.col = 0;\r\n\r\n\t\tthis.assets = assets;\r\n\r\n\t\tthis.directions = {\r\n\t\t\tRIGHT: \"right\",\r\n\t\t\tLEFT: \"left\",\r\n\t\t};\r\n\t\tthis.facing = this.directions.RIGHT;\r\n\r\n\t\tthis.spriteDict;\r\n\r\n\t\t// character movement\r\n\t\tthis.speed = 75;\r\n\t\tthis.maxSpeed = 100;\r\n\t\tthis.velocity = { x: 50, y: 50 };\r\n\t\tthis.goal = { x: 0, y: 0 };\r\n\t\tthis.position = pos;\r\n\r\n\t\tthis.states = {\r\n\t\t\tRUNNING: \"running\",\r\n\t\t\tKNOCKBACKED: \"knockedback\",\r\n\t\t\tATTACKING: \"attacking\",\r\n\t\t\tWINNING: \"winning\",\r\n\t\t\tDEAD: \"dead\",\r\n\t\t};\r\n\r\n\t\tthis.status = this.states.RUNNING;\r\n\r\n\t\tthis.time = 0;\r\n\t\tthis.attackTimer = 0;\r\n\t\tthis.attackCD = 900;\r\n\r\n\t\t// character attributes\r\n\t\tthis.maxHealth = 100;\r\n\t\tthis.health = 100;\r\n\t\tthis.dmg = 10;\r\n\t}\r\n\r\n\t// Drawing methods\r\n\r\n\tdraw(ctx, dt) {\r\n\t\tthis.imageTimer += dt;\r\n\t\tctx.fillStyle = \"#f00\";\r\n\t\t// draws name\r\n\t\tctx.fillText(this.name, this.position.x - this.nameLength.width / 2 + 40, this.position.y + this.height + 20);\r\n\r\n\t\t// if they are not dead, draw health and attack cooldown timer\r\n\t\tif (this.status != this.states.DEAD) {\r\n\t\t\tthis.drawHealth(ctx);\r\n\t\t\tthis.drawAttackCD(ctx);\r\n\t\t}\r\n\r\n\t\t// decides what to draw depending on state of character\r\n\t\tswitch (this.status) {\r\n\t\t\tcase this.states.RUNNING:\r\n\t\t\t\tthis.drawSpriteRunning(ctx);\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.states.KNOCKBACKED:\r\n\t\t\t\tthis.drawSpriteKBed(ctx);\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.states.ATTACKING:\r\n\t\t\t\tthis.drawSpriteAttacking(ctx);\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.states.WINNING:\r\n\t\t\t\tthis.drawSpriteWinning(ctx);\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.states.DEAD:\r\n\t\t\t\tthis.drawSpriteDead(ctx);\r\n\t\t}\r\n\r\n\t\t// handles sprite images, depending on time length per sprite frame\r\n\t\t// if timer for frame is up, move to next frame in animation\r\n\t\tif (this.imageTimer > this.imageTimerMax) {\r\n\t\t\tthis.col += 1;\r\n\t\t\tthis.imageTimer = 0;\r\n\t\t}\r\n\t}\r\n\r\n\t// draw health\r\n\tdrawHealth(ctx) {\r\n\t\tctx.fillStyle = \"lime\";\r\n\t\tctx.font = \"20px Arial\";\r\n\t\tctx.fillRect(this.position.x, this.position.y + this.height + 35, (this.health / this.maxHealth) * this.width, 10);\r\n\t\tctx.fillText(this.health + \" HP\", this.position.x, this.position.y + this.height + 35);\r\n\t}\r\n\r\n\t// draw attack cooldown\r\n\tdrawAttackCD(ctx) {\r\n\t\tctx.fillStyle = \"blue\";\r\n\t\tctx.fillRect(this.position.x, this.position.y + this.height + 50, (this.attackTimer / this.attackCD) * this.width, 10);\r\n\t}\r\n\r\n\t// draw running\r\n\tdrawSpriteRunning(ctx) {\r\n\t\t// sprite is constant loop over sprite animation\r\n\t\tlet sprite = this.getSpriteConstantLoop(\"running\");\r\n\r\n\t\t// draw reverse depending on velocity on x axis\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t// draw attacking\r\n\tdrawSpriteAttacking(ctx) {\r\n\t\t// sprite is only one loop - stops on last frame of animation\r\n\t\tlet sprite = this.getSpriteOneLoop(\"attacking\");\r\n\r\n\t\t// draw reverse depending on velocity on x axis\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t// draws if character is KBed\r\n\tdrawSpriteKBed(ctx) {\r\n\t\t// sprite is only one loop - stops on last frame of animation\r\n\t\tlet sprite = this.getSpriteOneLoop(\"knockedback\");\r\n\t\tctx.fillText(\"KBed\", this.position.x + this.width / 2 - ctx.measureText(\"KBed\").width / 2, this.position.y - 10);\r\n\r\n\t\t// draw reverse depending on velocity on x axis\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t// draws if character has won\r\n\tdrawSpriteWinning(ctx) {\r\n\t\t// runs on constant loop, draws WINNER text\r\n\t\tlet sprite = this.getSpriteConstantLoop(\"winning\");\r\n\t\tctx.fillStyle = \"fuchsia\";\r\n\t\tctx.fillText(\"WINNER\", this.position.x + this.width / 2 - ctx.measureText(\"WINNER\").width / 2, this.position.y - 10);\r\n\r\n\t\t// draw reverse depending on velocity on x axis\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.imageWinning, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.imageWinning, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t// draws character lying prone on ground\r\n\tdrawSpriteDead(ctx) {\r\n\t\tlet sprite = this.getSpriteOneLoop(\"knockedback\");\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t// each sprite frame is 80x80 so turns col/row into x/y coords\r\n\tspritePositionToImagePosition(col, row) {\r\n\t\treturn {\r\n\t\t\tx: this.border + col * (this.spacing + this.width),\r\n\t\t\ty: this.border + row * (this.spacing + this.height),\r\n\t\t};\r\n\t}\r\n\r\n\t// constant loop - if column gets to end of sprite sheet, reset back to beginning\r\n\tgetSpriteConstantLoop(condition) {\r\n\t\tif (this.col == this.spriteDict[condition][1][0]) {\r\n\t\t\tthis.col = this.spriteDict[condition][0][0];\r\n\t\t}\r\n\r\n\t\treturn this.spritePositionToImagePosition(this.col, this.row);\r\n\t}\r\n\r\n\t// one loop - if column gets to end, stay on the last frame\r\n\tgetSpriteOneLoop(condition) {\r\n\t\tif (this.col == this.spriteDict[condition][1][0]) {\r\n\t\t\tthis.col = this.spriteDict[condition][1][0] - 1;\r\n\t\t}\r\n\r\n\t\treturn this.spritePositionToImagePosition(this.col, this.row);\r\n\t}\r\n\r\n\t// set sprite frame - called when character changes state so animation can change\r\n\tsetSprite(condition) {\r\n\t\tthis.col = this.spriteDict[condition][0][0];\r\n\t\tthis.row = this.spriteDict[condition][0][1];\r\n\t}\r\n\r\n\t// Most getters and setters\r\n\r\n\tgetName() {\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\tgetPosition() {\r\n\t\treturn this.position;\r\n\t}\r\n\r\n\tsetPosition(newX, newY) {\r\n\t\tthis.position.x = newX;\r\n\t\tthis.position.y = newY;\r\n\t}\r\n\r\n\taddPosition(dx, dy) {\r\n\t\tthis.position.x += dx;\r\n\t\tthis.position.y += dy;\r\n\t}\r\n\r\n\tgetVelocity() {\r\n\t\treturn this.velocity;\r\n\t}\r\n\r\n\tsetVX(vx) {\r\n\t\tthis.velocity.x = vx;\r\n\t}\r\n\r\n\tmultiplyVX(multiple) {\r\n\t\tthis.velocity.x *= multiple;\r\n\t}\r\n\r\n\tsetVY(vy) {\r\n\t\tthis.velocity.y = vy;\r\n\t}\r\n\r\n\tmultiplyVY(multiple) {\r\n\t\tthis.velocity.y *= multiple;\r\n\t}\r\n\r\n\tgetHeight() {\r\n\t\treturn this.height;\r\n\t}\r\n\r\n\tgetWidth() {\r\n\t\treturn this.width;\r\n\t}\r\n\r\n\tgetGoal() {\r\n\t\treturn this.goal;\r\n\t}\r\n\r\n\tgetTimeKnockedback() {\r\n\t\treturn this.time;\r\n\t}\r\n\r\n\taddTimeKnockedback(dt) {\r\n\t\tthis.time += dt;\r\n\t}\r\n\r\n\tsetTimeKnockedback(dt) {\r\n\t\tthis.time = dt;\r\n\t}\r\n\r\n\tminusHealth(dmg) {\r\n\t\tthis.health -= dmg;\r\n\t}\r\n\r\n\tisDead() {\r\n\t\tif (this.health <= 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tgetAttackTimer() {\r\n\t\treturn this.attackTimer;\r\n\t}\r\n\r\n\tsetAttackTimer(time) {\r\n\t\tthis.attackTimer = time;\r\n\t}\r\n\r\n\tcooldownAttackTimer(dt) {\r\n\t\tif (this.attackTimer - dt < 0) {\r\n\t\t\tthis.attackTimer = 0;\r\n\t\t} else {\r\n\t\t\tthis.attackTimer -= dt;\r\n\t\t}\r\n\t}\r\n\r\n\tgetTimeForAttackAnimation() {\r\n\t\treturn this.timeforAttackAnimation;\r\n\t}\r\n\r\n\tgetID() {\r\n\t\treturn this.id;\r\n\t}\r\n\r\n\tgetFacing() {\r\n\t\treturn this.facing;\r\n\t}\r\n\r\n\tsetFacing(dir) {\r\n\t\tthis.facing = dir;\r\n\t}\r\n\r\n\tsetStatus(status) {\r\n\t\tthis.status = status;\r\n\t}\r\n\r\n\tgetStatus() {\r\n\t\treturn this.status;\r\n\t}\r\n\r\n\tgetDmg() {\r\n\t\treturn this.dmg;\r\n\t}\r\n\r\n\t// Movement related methods\r\n\r\n\t// keeps character inside field\r\n\tkeepInside() {\r\n\t\tif (this.position.x <= 1) {\r\n\t\t\tthis.position.x = 5;\r\n\t\t\tthis.velocity.x = 0;\r\n\t\t}\r\n\r\n\t\tif (this.position.x >= this.gameWidth - this.width - 1) {\r\n\t\t\tthis.position.x = this.gameWidth - this.width - 5;\r\n\t\t\tthis.velocity.x = 0;\r\n\t\t}\r\n\r\n\t\tif (this.position.y <= 80) {\r\n\t\t\tthis.position.y = 81;\r\n\t\t\tthis.velocity.y = 0;\r\n\t\t}\r\n\r\n\t\tif (this.position.y >= this.gameHeight - this.height - 1) {\r\n\t\t\tthis.position.y = this.gameHeight - this.height - 5;\r\n\t\t\tthis.velocity.y = 0;\r\n\t\t}\r\n\t}\r\n\r\n\t// finds closest enemy and returns it\r\n\tgetClosestEnemy(characterList) {\r\n\t\tlet closest;\r\n\t\tlet closestDist = 999999;\r\n\t\tfor (let i = 0; i < characterList.length; i++) {\r\n\t\t\tlet dist = this.getDist(characterList[i]);\r\n\t\t\tif (dist < closestDist && characterList[i].getID() != this.id && characterList[i].getStatus() != this.states.KNOCKBACKED) {\r\n\t\t\t\tclosestDist = dist;\r\n\t\t\t\tclosest = characterList[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn closest;\r\n\t}\r\n\r\n\t// sets goal to closest enemy - if the goal is null,stop moving as character has won\r\n\tsetGoal(character) {\r\n\t\tif (character != null) {\r\n\t\t\tthis.goal = character.getPosition();\r\n\t\t} else {\r\n\t\t\tthis.goal = { x: this.position.x, y: this.position.y };\r\n\t\t\tthis.velocity.x = 0;\r\n\t\t\tthis.velocity.y = 0;\r\n\t\t}\r\n\t}\r\n\r\n\t//some get functions relating to movement\r\n\r\n\tgetGoal() {\r\n\t\treturn this.goal;\r\n\t}\r\n\r\n\t// gets dist from character\r\n\tgetDist(character) {\r\n\t\tlet pos = character.getPosition();\r\n\t\tlet part1 = Math.pow(this.position.x - pos.x, 2);\r\n\t\tlet part2 = Math.pow(this.position.y - pos.y, 2);\r\n\r\n\t\treturn Math.pow(part1 + part2, 0.5);\r\n\t}\r\n\r\n\t// turns distance into a unit vector\r\n\tgetUnitVector() {\r\n\t\tlet part1 = this.goal.x - this.position.x;\r\n\t\tlet part2 = this.goal.y - this.position.y;\r\n\t\tlet magnitude = Math.pow(Math.pow(part1, 2) + Math.pow(part2, 2), 0.5);\r\n\r\n\t\treturn { x: part1 / magnitude, y: part2 / magnitude };\r\n\t}\r\n\r\n\t// update movement of character based on goal\r\n\tupdateVelocities() {\r\n\t\tlet d1 = this.goal.x - this.position.x;\r\n\t\tlet d2 = this.goal.y - this.position.y;\r\n\r\n\t\t// checking to see if distance to goal == 0\r\n\t\tif (d1 != 0 && d2 != 0) {\r\n\t\t\t// gets a unit vector to get speed of this object\r\n\t\t\tlet unitVector = this.getUnitVector();\r\n\r\n\t\t\t// 75 pixels total movement per second\r\n\t\t\tthis.velocity.x = unitVector.x * this.speed;\r\n\t\t\tthis.velocity.y = unitVector.y * this.speed;\r\n\t\t}\r\n\t}\r\n\r\n\t// changes this.facing letiable based on velocity of x\r\n\tupdateDirection() {\r\n\t\tif (this.velocity.x < 0) {\r\n\t\t\tthis.facing = \"left\";\r\n\t\t} else if (this.velocity.x > 0) {\r\n\t\t\tthis.facing = \"right\";\r\n\t\t}\r\n\t}\r\n\r\n\t// hits the other player passed in\r\n\t// changes other velocity\r\n\t// sets this character attack on cooldown\r\n\t// TODO: maybe random damage instead of 10?\r\n\thit(other, dt) {\r\n\t\tif (this.status == this.states.ATTACKING) {\r\n\t\t} else {\r\n\t\t\tother.setTimeKnockedback(dt);\r\n\r\n\t\t\tlet otherV = other.getVelocity();\r\n\r\n\t\t\tother.addPosition(Math.sign(otherV.x) * -10, Math.sign(otherV.y) * -10);\r\n\r\n\t\t\tother.setVX(otherV.x * -7.5 + (Math.floor(Math.random() * 5) * Math.random() < 0.5 ? -1 : 1));\r\n\t\t\tother.setVY(otherV.y * -7.5 + (Math.floor(Math.random() * 5) * Math.random() < 0.5 ? -1 : 1));\r\n\r\n\t\t\tthis.attackTimer = this.attackCD;\r\n\t\t}\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/character.js?");

/***/ }),

/***/ "./src/collision.js":
/*!**************************!*\
  !*** ./src/collision.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Collision)\n/* harmony export */ });\nclass Collision {\r\n\t// collision class that is used to handle collisions\r\n\tconstructor(obj1, obj2, dir, time) {\r\n\t\tthis.objectIndex1 = obj1;\r\n\t\tthis.objectIndex2 = obj2;\r\n\t\tthis.direction = dir;\r\n\t\tthis.time = time;\r\n\t}\r\n\r\n\tgetObj1() {\r\n\t\treturn this.objectIndex1;\r\n\t}\r\n\r\n\tgetObj2() {\r\n\t\treturn this.objectIndex2;\r\n\t}\r\n\r\n\tgetTime() {\r\n\t\treturn this.time;\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/collision.js?");

/***/ }),

/***/ "./src/damagesplat.js":
/*!****************************!*\
  !*** ./src/damagesplat.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DamageSplat)\n/* harmony export */ });\nclass DamageSplat {\r\n\tconstructor(pos, number, assets) {\r\n\t\tthis.pos = pos;\r\n\t\tthis.number = number;\r\n\t\tthis.assets = assets;\r\n\t\tthis.time = 0;\r\n\t\tthis.width = 40;\r\n\t\tthis.height = 40;\r\n\t}\r\n\r\n\tupdateTime(step) {\r\n\t\tthis.time += step;\r\n\t}\r\n\r\n\tgetTime() {\r\n\t\treturn this.time;\r\n\t}\r\n\r\n\t// draws damage splat\r\n\tdraw(ctx) {\r\n\t\t// draws blue splat if damage is 0 and red otherwise\r\n\t\tif (this.number == 0) {\r\n\t\t\tctx.drawImage(this.assets[1], this.pos.x, this.pos.y);\r\n\t\t} else {\r\n\t\t\tctx.drawImage(this.assets[0], this.pos.x, this.pos.y);\r\n\t\t}\r\n\t\tctx.fillStyle = \"white\";\r\n\t\tctx.fillText(\"\" + this.number, this.pos.x + this.width / 2 - ctx.measureText(\"\" + this.number).width / 2, this.pos.y + this.height / 2 + 5);\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/damagesplat.js?");

/***/ }),

/***/ "./src/firzen.js":
/*!***********************!*\
  !*** ./src/firzen.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Firzen)\n/* harmony export */ });\n/* harmony import */ var _character_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character.js */ \"./src/character.js\");\n\r\n\r\nclass Firzen extends _character_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n\tconstructor(gameWidth, gameHeight, name, pos, image, id, assets, ctx) {\r\n\t\tsuper(gameWidth, gameHeight, name, pos, image, id, assets, ctx);\r\n\r\n\t\tthis.image = this.assets[0];\r\n\t\tthis.imageWinning = this.assets[1];\r\n\r\n\t\t// custom column/row coords from sprite sheet\r\n\t\tthis.spriteDict = {\r\n\t\t\trunning: [\r\n\t\t\t\t[0, 2],\r\n\t\t\t\t[3, 2],\r\n\t\t\t],\r\n\t\t\tknockedback: [\r\n\t\t\t\t[0, 3],\r\n\t\t\t\t[5, 3],\r\n\t\t\t],\r\n\t\t\tattacking: [\r\n\t\t\t\t[4, 1],\r\n\t\t\t\t[7, 1],\r\n\t\t\t],\r\n\t\t\twinning: [\r\n\t\t\t\t[4, 0],\r\n\t\t\t\t[10, 0],\r\n\t\t\t],\r\n\t\t};\r\n\r\n\t\t// time needed for animation to attack\r\n\t\t// catches error if time is  < 0\r\n\t\tthis.timeforAttackAnimation =\r\n\t\t\t(this.attackCD - (this.spriteDict[\"attacking\"][1][0] - this.spriteDict[\"attacking\"][0][0]) * this.imageTimerMax) * 0.5;\r\n\r\n\t\tif (this.timeforAttackAnimation <= 0) {\r\n\t\t\tconsole.log(\"ERROR 0 for timeForAttackAnimation\");\r\n\t\t}\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/firzen.js?");

/***/ }),

/***/ "./src/henry.js":
/*!**********************!*\
  !*** ./src/henry.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Henry)\n/* harmony export */ });\n/* harmony import */ var _character_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character.js */ \"./src/character.js\");\n\r\n\r\nclass Henry extends _character_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n\tconstructor(gameWidth, gameHeight, name, pos, image, id, assets, ctx) {\r\n\t\tsuper(gameWidth, gameHeight, name, pos, image, id, assets, ctx);\r\n\r\n\t\tthis.image = this.assets[0];\r\n\t\tthis.imageAttacking = this.assets[1];\r\n\t\tthis.imageWinning = this.assets[2];\r\n\r\n\t\t// custom column/row coords from sprite sheet\r\n\t\tthis.spriteDict = {\r\n\t\t\trunning: [\r\n\t\t\t\t[0, 2],\r\n\t\t\t\t[3, 2],\r\n\t\t\t],\r\n\t\t\tknockedback: [\r\n\t\t\t\t[0, 3],\r\n\t\t\t\t[5, 3],\r\n\t\t\t],\r\n\t\t\tattacking: [\r\n\t\t\t\t[0, 0],\r\n\t\t\t\t[4, 0],\r\n\t\t\t],\r\n\t\t\twinning: [\r\n\t\t\t\t[0, 0],\r\n\t\t\t\t[4, 0],\r\n\t\t\t],\r\n\t\t};\r\n\t\t// time needed for animation to attack\r\n\t\t// catches error if time is  < 0\r\n\t\tthis.timeforAttackAnimation =\r\n\t\t\t(this.attackCD - (this.spriteDict[\"attacking\"][1][0] - this.spriteDict[\"attacking\"][0][0]) * this.imageTimerMax) * 0.5;\r\n\t\tif (this.timeforAttackAnimation <= 0) {\r\n\t\t\tconsole.log(\"ERROR 0 for timeForAttackAnimation\");\r\n\t\t}\r\n\t}\r\n\r\n\t// henry has slightly different attacking as his comes from a different sprite sheet than normal\r\n\tdrawSpriteAttacking(ctx) {\r\n\t\tvar sprite = this.getSpriteOneLoop(\"attacking\");\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.imageAttacking, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.imageAttacking, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/henry.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _woody_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./woody.js */ \"./src/woody.js\");\n/* harmony import */ var _firzen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firzen.js */ \"./src/firzen.js\");\n/* harmony import */ var _henry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./henry.js */ \"./src/henry.js\");\n/* harmony import */ var _julian_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./julian.js */ \"./src/julian.js\");\n/* harmony import */ var _justin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./justin.js */ \"./src/justin.js\");\n/* harmony import */ var _collision_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./collision.js */ \"./src/collision.js\");\n/* harmony import */ var _damagesplat_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./damagesplat.js */ \"./src/damagesplat.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst MIN_STEP = 10;\r\nconst SPRITE_HEIGHT = 80;\r\n\r\nlet PLAYERS = 0;\r\n\r\n// states of each character\r\nconst states = {\r\n\tRUNNING: \"running\",\r\n\tKNOCKEDBACK: \"knockedback\",\r\n\tATTACKING: \"attacking\",\r\n\tWINNING: \"winning\",\r\n\tDEAD: \"dead\",\r\n};\r\n\r\n// load all assets first\r\n\r\nlet woodyImage = new Image();\r\nwoodyImage.src = \"Assets/woody.png\";\r\n\r\nlet woodyImageWinning = new Image();\r\nwoodyImageWinning.src = \"Assets/woody2.png\";\r\n\r\nlet woodyAssets = [woodyImage, woodyImageWinning];\r\n\r\nlet firzenImage = new Image();\r\nfirzenImage.src = \"Assets/firzen.png\";\r\n\r\nlet firzenImageWinning = new Image();\r\nfirzenImageWinning.src = \"Assets/firzen1.png\";\r\n\r\nlet firzenAssets = [firzenImage, firzenImageWinning];\r\n\r\nlet henryImage = new Image();\r\nhenryImage.src = \"Assets/henry.png\";\r\n\r\nlet henryImageAttacking = new Image();\r\nhenryImageAttacking.src = \"Assets/henryAttacking.png\";\r\n\r\nlet henryImageWinning = new Image();\r\nhenryImageWinning.src = \"Assets/henry2.png\";\r\n\r\nlet henryAssets = [henryImage, henryImageAttacking, henryImageWinning];\r\n\r\nlet justinImage = new Image();\r\njustinImage.src = \"Assets/justin0.png\";\r\n\r\nlet justinImageAttacking = new Image();\r\njustinImageAttacking.src = \"Assets/justin1.png\";\r\n\r\nlet justinAssets = [justinImage, justinImageAttacking];\r\n\r\nlet bg = new Image();\r\nbg.src = \"Assets/bg1.png\";\r\n\r\nlet damageSplatRed = new Image();\r\nlet damageSplatBlue = new Image();\r\n\r\ndamageSplatRed.src = \"Assets/dmgsplat_red.png\";\r\ndamageSplatBlue.src = \"Assets/dmgsplat_blue.png\";\r\n\r\nlet damageSplatAssets = [damageSplatRed, damageSplatBlue];\r\n\r\nlet element = document.getElementById(\"deathlist\");\r\n\r\n// clamping frames so they are not too long or short\r\nlet typicalFrame = 16;\r\nlet smallestFrame = 14;\r\nlet longestFrame = 50;\r\n\r\n// gameloop that controls the game\r\nfunction gameLoop(timestamp) {\r\n\tlet deltaTime = timestamp - lastTime;\r\n\tif (deltaTime > longestFrame) deltaTime = typicalFrame;\r\n\r\n\tlastTime = timestamp;\r\n\r\n\tctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n\t// controls all calculations of each character\r\n\tupdateGame(deltaTime, ctx);\r\n\r\n\t// updates list of dead characters based on characters that are in the deathListNames array\r\n\telement.innerHTML = \"\";\r\n\tfor (let i = 0; i < deathListNames.length; i++) {\r\n\t\telement.innerHTML = element.innerHTML + (i + 1) + \". \" + deathListNames[i] + \"<br />\";\r\n\t}\r\n\r\n\t// Finds if game has ended and sends data to server as a JSON\r\n\tif (deathListNames.length == PLAYERS - 1) {\r\n\t\tdeathListNames.push(characterList[0].getName());\r\n\r\n\t\tconst data = { deathListNames, beginning };\r\n\r\n\t\tconst options = {\r\n\t\t\tmethod: \"POST\",\r\n\t\t\theaders: {\r\n\t\t\t\t\"Content-Type\": \"application/json\",\r\n\t\t\t},\r\n\t\t\tbody: JSON.stringify(data),\r\n\t\t};\r\n\r\n\t\tfetch(\"/api\", options)\r\n\t\t\t.then((response) => response.json())\r\n\t\t\t.then((json) => {\r\n\t\t\t\tconsole.log(json);\r\n\t\t\t});\r\n\r\n\t\tPLAYERS = -999;\r\n\t}\r\n\r\n\trequestAnimationFrame(gameLoop);\r\n}\r\n\r\n// handles all calculations of characters by time\r\nfunction updateGame(dt, ctx) {\r\n\tlet step = dt;\r\n\tdo {\r\n\t\t// first finds if there is at least one collision between characters\r\n\t\tlet hit = findFirstCollision(step);\r\n\r\n\t\t// if there is at least one collision, find all collisions by turning them into collision objects, handle them, and move each character\r\n\t\tif (hit != null) {\r\n\t\t\tstep = Math.max(hit.getTime(), MIN_STEP);\r\n\t\t\tupdateObjects(step);\r\n\t\t\thandleCollisions(step);\r\n\t\t\t// else just move each character\r\n\t\t} else {\r\n\t\t\tupdateObjects(step);\r\n\t\t}\r\n\r\n\t\t// drawing portion\r\n\r\n\t\t// draw bg\r\n\t\tctx.drawImage(bg, 0, 0);\r\n\r\n\t\t// draw dead characters as lying prone on the ground\r\n\t\tfor (let i = 0; i < deathListObjects.length; i++) {\r\n\t\t\tdeathListObjects[i].draw(ctx, step);\r\n\t\t}\r\n\r\n\t\t//draw alive characters either as KBed or running or winning\r\n\t\tfor (let i = 0; i < characterList.length; i++) {\r\n\t\t\tcharacterList[i].draw(ctx, step);\r\n\t\t}\r\n\r\n\t\t// draw damage splats\r\n\t\tfor (let i = 0; i < damageSplats.length; i++) {\r\n\t\t\tdamageSplats[i].draw(ctx);\r\n\r\n\t\t\tdamageSplats[i].updateTime(step);\r\n\t\t\tif (damageSplats[i].getTime() > 2000) {\r\n\t\t\t\tdamageSplats.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// finds if there is only 1 character left alive and makes him celebrate\r\n\t\tif (characterList.length == 1) {\r\n\t\t\tif (characterList[0].getStatus() != states.WINNING) {\r\n\t\t\t\tcharacterList[0].setSprite(states.WINNING);\r\n\t\t\t}\r\n\t\t\tcharacterList[0].setStatus(states.WINNING);\r\n\t\t}\r\n\r\n\t\tdt -= step;\r\n\t\tstep = dt;\r\n\t} while (dt > 0);\r\n}\r\n\r\n// function that handles moving the characters around and recognising when they are dead\r\nfunction updateObjects(step) {\r\n\tfor (let i = 0; i < characterList.length; i++) {\r\n\t\tlet character = characterList[i];\r\n\t\tlet pos = character.getPosition();\r\n\t\tlet v = character.getVelocity();\r\n\r\n\t\t// keeps characters within a boundary\r\n\t\tcharacter.keepInside();\r\n\r\n\t\t// if character has a cooldown on their attack, reduce it by time passed\r\n\t\tcharacter.cooldownAttackTimer(step);\r\n\r\n\t\t// if character is dead, push him into dead list and remove him from alive list\r\n\t\tif (character.isDead()) {\r\n\t\t\tdeathListNames.push(character.getName());\r\n\r\n\t\t\tcharacter.setStatus(states.DEAD);\r\n\t\t\tdeathListObjects.push(character);\r\n\r\n\t\t\tcharacterList.splice(i, 1);\r\n\t\t\ti--;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t// handles if character is KBed by another - pushes them back in the opposite direction they were running in\r\n\t\tif (character.getStatus() == states.KNOCKEDBACK) {\r\n\t\t\tcharacter.setVX(v.x * 0.95);\r\n\t\t\tcharacter.setVY(v.y * 0.95);\r\n\t\t\tcharacter.setPosition(pos.x + (step * v.x) / 1000, pos.y + (step * v.y) / 1000);\r\n\t\t\tcharacter.addTimeKnockedback(step);\r\n\r\n\t\t\t// if they reach the time limit on being KBed, reset them back to running state\r\n\t\t\tif (character.getTimeKnockedback() > 1000) {\r\n\t\t\t\tcharacter.setStatus(states.RUNNING);\r\n\t\t\t\tcharacter.setSprite(states.RUNNING);\r\n\t\t\t\tcharacter.setTimeKnockedback(0);\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise if they are not KBed, set a goal destination to the nearest enemy where they will run to\r\n\t\t} else {\r\n\t\t\tcharacter.setGoal(character.getClosestEnemy(characterList));\r\n\t\t\tcharacter.updateVelocities();\r\n\r\n\t\t\tcharacter.setPosition(pos.x + (step * v.x) / 1000, pos.y + (step * v.y) / 1000);\r\n\t\t}\r\n\r\n\t\t// if a character has completed an attack animation, reset them back to running state.\r\n\t\tif (character.getAttackTimer() < character.getTimeForAttackAnimation() && character.getStatus() == states.ATTACKING) {\r\n\t\t\tcharacter.setSprite(states.RUNNING);\r\n\t\t\tcharacter.setStatus(states.RUNNING);\r\n\t\t}\r\n\r\n\t\t// if character is running, update the direction they face (left if negative movement, right if positive movement)\r\n\t\tif (character.getStatus() == states.RUNNING) {\r\n\t\t\tcharacter.updateDirection();\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// handles each collision - is passed a collision and decides who gets hit and who is the one hitting\r\n// returns dmg number and character that gets hit\r\nfunction updateVelocities(collision, step) {\r\n\tlet obj1 = collision.getObj1();\r\n\tlet obj2 = collision.getObj2();\r\n\r\n\tlet rand = Math.floor(Math.random() * 15);\r\n\tconsole.log(rand);\r\n\r\n\t// make sure that in the collision object, the two colliding objects are not null\r\n\tif (obj1 != null && obj2 != null) {\r\n\t\t//if they are not nulls, check their attack cooldown timers\r\n\r\n\t\t//if obj1 is ready to attack but obj2 isn't, obj2 will definitely getting hit\r\n\t\tif (obj1.getAttackTimer() == 0 && obj2.getAttackTimer() != 0) {\r\n\t\t\tif (obj1.getStatus() != states.KNOCKEDBACK && obj2.getStatus() != states.KNOCKEDBACK) {\r\n\t\t\t\tobj1.hit(obj2, step);\r\n\t\t\t\tupdateStatus(obj1, obj2);\r\n\t\t\t\tupdateHealth(obj1, obj2, rand);\r\n\t\t\t\treturn [obj2, rand];\r\n\t\t\t}\r\n\t\t\t//vice versa\r\n\t\t} else if (obj1.getAttackTimer() != 0 && obj2.getAttackTimer() == 0) {\r\n\t\t\tif (obj1.getStatus() != states.KNOCKEDBACK && obj2.getStatus() != states.KNOCKEDBACK) {\r\n\t\t\t\tobj2.hit(obj1, step);\r\n\t\t\t\tupdateStatus(obj2, obj1);\r\n\t\t\t\tupdateHealth(obj2, obj1, rand);\r\n\t\t\t\treturn [obj1, rand];\r\n\t\t\t}\r\n\r\n\t\t\t// if both characters have their attack ready, it will be a 50/50 on who gets hit\r\n\t\t} else if (obj1.getAttackTimer() == 0 && obj2.getAttackTimer() == 0) {\r\n\t\t\tlet coinflip = Math.floor(Math.random() * 2);\r\n\r\n\t\t\tif (coinflip == 0) {\r\n\t\t\t\tif (obj1.getStatus() != states.KNOCKEDBACK && obj2.getStatus() != states.KNOCKEDBACK) {\r\n\t\t\t\t\tobj1.hit(obj2, step);\r\n\t\t\t\t\tupdateStatus(obj1, obj2);\r\n\t\t\t\t\tupdateHealth(obj1, obj2, rand);\r\n\t\t\t\t\treturn [obj2, rand];\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (obj1.getStatus() != states.KNOCKEDBACK && obj2.getStatus() != states.KNOCKEDBACK) {\r\n\t\t\t\t\tobj2.hit(obj1, step);\r\n\t\t\t\t\tupdateStatus(obj2, obj1);\r\n\t\t\t\t\tupdateHealth(obj2, obj1, rand);\r\n\t\t\t\t\treturn [obj1, rand];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// function that handles all collisions\r\nfunction handleCollisions(step) {\r\n\t// finds all collisions, set up unique collisions and charactersSeen as an collision between Char1 and Char2 is also a collision between Char2 and Char1\r\n\t// we don't want that to register as two seperate collisions\r\n\tlet allCollisions = findAllCollisions(step);\r\n\tlet uniqueCollisions = [];\r\n\tlet charactersSeen = [];\r\n\r\n\t// look at each individual collision\r\n\tfor (let i = 0; i < allCollisions.length; i++) {\r\n\t\tlet obj1 = allCollisions[i].getObj1();\r\n\t\tlet obj2 = allCollisions[i].getObj2();\r\n\r\n\t\t// if they are both not in the characterSeen array, push their unique ID and their collision in\r\n\t\tif (!charactersSeen.includes(obj1.getID()) && !charactersSeen.includes(obj2.getID())) {\r\n\t\t\tcharactersSeen.push(obj1.getID());\r\n\t\t\tcharactersSeen.push(obj2.getID());\r\n\t\t\tuniqueCollisions.push(allCollisions[i]);\r\n\t\t}\r\n\t}\r\n\r\n\t// using all unique collisions, handle each unique collision using the function above\r\n\tfor (let collision of uniqueCollisions) {\r\n\t\tlet info = updateVelocities(collision, step);\r\n\t\tif (info != undefined) {\r\n\t\t\tcreateDamageSplats(info[0].getPosition(), info[1]);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// finds all collisions by comparing each character to see if their hitboxes overlap and returns a array of all collisions\r\nfunction findAllCollisions(dt) {\r\n\tlet collisions = [];\r\n\tfor (let i = 0; i < characterList.length; ++i) {\r\n\t\tfor (let j = i + 1; j < characterList.length; ++j) {\r\n\t\t\tlet hit = findCollision(i, j, dt);\r\n\t\t\tif (hit != null) {\r\n\t\t\t\tcollisions.push(hit);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn collisions;\r\n}\r\n\r\n// function that finds 1 collision to see if we need to run findAllCollisions func\r\nfunction findFirstCollision(dt) {\r\n\tfor (let i = 0; i < characterList.length; i++) {\r\n\t\tfor (let j = i + 1; j < characterList.length; j++) {\r\n\t\t\tlet hit = findCollision(i, j, dt);\r\n\t\t\tif (hit != null) {\r\n\t\t\t\treturn hit;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// checks to see if there is a collision between characters at index i and j by checking overlaps of hitboxes\r\n// if there is, create a Collision object and return it to findAllCollisions func\r\nfunction findCollision(i, j, dt) {\r\n\tlet obj1 = characterList[i];\r\n\tlet obj2 = characterList[j];\r\n\tlet obj1Pos = obj1.getPosition();\r\n\tlet obj2Pos = obj2.getPosition();\r\n\tif (\r\n\t\tobj1Pos.x <= obj2Pos.x + obj2.getWidth() &&\r\n\t\tobj1Pos.x + obj1.getWidth() >= obj2Pos.x &&\r\n\t\tobj1Pos.y + obj1.getHeight() >= obj2Pos.y &&\r\n\t\tobj1Pos.y <= obj2Pos.y + obj2.getHeight()\r\n\t) {\r\n\t\tlet dir = 0;\r\n\t\tlet col = new _collision_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](obj1, obj2, dir, dt);\r\n\t\treturn col;\r\n\t}\r\n\treturn null;\r\n}\r\n\r\n// creates damage splat object and appends it to the damage splat list\r\nfunction createDamageSplats(location, number) {\r\n\tlet damageSplat = new _damagesplat_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](location, number, damageSplatAssets);\r\n\tdamageSplats.push(damageSplat);\r\n}\r\n\r\n// updates statuses between two characters hitting each other - one hits, one gets KBed\r\nfunction updateStatus(obj1, obj2) {\r\n\t// obj1 is the hitter, obj2 is the hittee(is that a word?)\r\n\tobj1.setStatus(states.ATTACKING);\r\n\tobj1.setSprite(states.ATTACKING);\r\n\r\n\tobj2.setStatus(states.KNOCKEDBACK);\r\n\tobj2.setSprite(states.KNOCKEDBACK);\r\n}\r\n\r\n// updates health after a collision\r\nfunction updateHealth(obj1, obj2, dmg) {\r\n\t// obj1 is the hitter, obj2 is the hittee\r\n\t//let dmg = obj1.getDmg();\r\n\tobj2.minusHealth(dmg);\r\n}\r\n\r\n// function used when generating characters at the beginning to make sure when they spawn they\r\n// do not overlap - keeps generating random coords until no overlaps are found\r\nfunction checkXYOverlap(xpos, ypos, characterList) {\r\n\tfor (const character of characterList) {\r\n\t\tif (character.getPosition().x == xpos && character.getPosition().y == ypos) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n// gets a random 80x80 tile\r\nfunction getRandomTile(max_tiles) {\r\n\t// tile size of 80x80 - 9 up, 12 across\r\n\treturn Math.floor(Math.random() * max_tiles);\r\n}\r\n\r\n// canvas is the screen where action happens\r\nlet canvas = document.getElementById(\"gameScreen\");\r\ncanvas.height = 720;\r\ncanvas.width = 960;\r\n\r\nlet ctx = canvas.getContext(\"2d\");\r\nctx.font = \"16px Arial\";\r\n\r\nconst GAME_WIDTH = 960;\r\nconst GAME_HEIGHT = 720;\r\n\r\nctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n// arrays to store info\r\nlet names = [];\r\nlet characterList = [];\r\n\r\n// store all char at beginning\r\nlet beginning = [];\r\n\r\n// arrays to store names and actual objects of dead chars\r\nlet deathListNames = [];\r\nlet deathListObjects = [];\r\n\r\n// array for damage splats\r\nlet damageSplats = [];\r\n\r\n// adds an event listener to the start button to begin simulation\r\ndocument.getElementById(\"start\").addEventListener(\"click\", () => {\r\n\t// gets all names entered in textbox, one name per each line, gets rid of lines with nothing in them\r\n\tnames = $(\"#entries\").val().split(\"\\n\");\r\n\tfor (let i = names.length - 1; i > -1; i--) {\r\n\t\tif (names[i].trim() == \"\") {\r\n\t\t\tnames.splice(i, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t// max names of 24 so screen doesn't get too overcrowded\r\n\tif (names.length > 24) {\r\n\t\tnames = [];\r\n\t}\r\n\r\n\tbeginning.push(names);\r\n\r\n\tdeathListNames = [];\r\n\tdeathListObjects = [];\r\n\tcharacterList = [];\r\n\tdamageSplats = [];\r\n\r\n\tPLAYERS = names.length;\r\n\r\n\t// generates character location\r\n\r\n\tfor (let i = 0; i < names.length; i++) {\r\n\t\tlet xp = getRandomTile(6) * SPRITE_HEIGHT * 2 + SPRITE_HEIGHT;\r\n\t\tlet yp = getRandomTile(3) * SPRITE_HEIGHT * 2 + SPRITE_HEIGHT;\r\n\r\n\t\twhile (checkXYOverlap(xp, yp, characterList)) {\r\n\t\t\txp = getRandomTile(6) * SPRITE_HEIGHT * 2 + SPRITE_HEIGHT;\r\n\t\t\typ = getRandomTile(4) * SPRITE_HEIGHT * 2 + SPRITE_HEIGHT;\r\n\t\t}\r\n\r\n\t\tlet pos = { x: xp, y: yp };\r\n\r\n\t\tlet rand = Math.floor(Math.random() * 4);\r\n\r\n\t\t// generates a random character out of 4\r\n\t\t// TODO: add more characters\r\n\r\n\t\tlet character;\r\n\t\tif (rand == 0) {\r\n\t\t\tcharacter = new _henry_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](GAME_WIDTH, GAME_HEIGHT, names[i], pos, i, henryAssets, ctx);\r\n\t\t} else if (rand == 1) {\r\n\t\t\tcharacter = new _firzen_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](GAME_WIDTH, GAME_HEIGHT, names[i], pos, i, firzenAssets, ctx);\r\n\t\t} else if (rand == 2) {\r\n\t\t\tcharacter = new _woody_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](GAME_WIDTH, GAME_HEIGHT, names[i], pos, i, woodyAssets, ctx);\r\n\t\t} else if (rand == 3) {\r\n\t\t\tcharacter = new _justin_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](GAME_WIDTH, GAME_HEIGHT, names[i], pos, i, justinAssets, ctx);\r\n\t\t}\r\n\r\n\t\tcharacterList.push(character);\r\n\t}\r\n});\r\n\r\n// Controlling the navbar when page gets too narrow\r\nconst toggleButton = document.getElementsByClassName(\"toggle-button\")[0];\r\nconst mobileMenu = document.getElementsByClassName(\"mobile-nav\")[0];\r\n\r\ntoggleButton.addEventListener(\"click\", () => {\r\n\tmobileMenu.classList.toggle(\"active\");\r\n});\r\n\r\nwindow.addEventListener(\"resize\", () => {\r\n\tif (window.matchMedia(\"(min-width: 600px)\").matches) {\r\n\t\tmobileMenu.classList.remove(\"active\");\r\n\t}\r\n});\r\n\r\n// Controlling game info and how to tabs\r\n\r\nfunction openInfoTab(tabname, tabid) {\r\n\tlet infoContainers = document.getElementsByClassName(\"info\");\r\n\tfor (let i = 0; i < infoContainers.length; i++) {\r\n\t\tinfoContainers[i].style.display = \"none\";\r\n\t}\r\n\r\n\tlet tabs = document.getElementsByClassName(\"tab\");\r\n\tlet info = document.getElementsByClassName(\"info\");\r\n\r\n\tfor (let i = 0; i < tabs.length; i++) {\r\n\t\ttabs[i].classList.remove(\"active\");\r\n\t}\r\n\tdocument.getElementById(tabname).style.display = \"block\";\r\n\tdocument.getElementById(tabid).classList.toggle(\"active\");\r\n}\r\n\r\n// controlling bouncing arrow functions\r\n\r\nconst arrowIcon = document.getElementsByClassName(\"arrow-icon\")[0];\r\n\r\narrowIcon.addEventListener(\"click\", () => {\r\n\twindow.scrollTo({ top: window.innerHeight, behavior: \"smooth\" });\r\n});\r\n\r\nlet lastTime = 0;\r\n\r\ngameLoop(characterList);\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/index.js?");

/***/ }),

/***/ "./src/julian.js":
/*!***********************!*\
  !*** ./src/julian.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Julian)\n/* harmony export */ });\n/* harmony import */ var _character_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character.js */ \"./src/character.js\");\n\r\n//TODO: WORK IN PROGRESS\r\nclass Julian extends _character_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n\tconstructor(gameWidth, gameHeight, name, pos, image, id, ctx) {\r\n\t\tsuper(gameWidth, gameHeight, name, pos, image, id, ctx);\r\n\r\n\t\tthis.height = 100;\r\n\r\n\t\tthis.spriteSheetJulian0 = \"Assets/julian0.png\";\r\n\t\tthis.spriteSheetJulian1 = \"Assets/julian1.png\";\r\n\r\n\t\tthis.image0 = new Image();\r\n\t\tthis.image0.src = this.spriteSheetJulian0;\r\n\t\tthis.image0.crossOrigin = true;\r\n\r\n\t\tthis.image1 = new Image();\r\n\t\tthis.image1.src = this.spriteSheetJulian1;\r\n\t\tthis.image1.crossOrigin = true;\r\n\r\n\t\tthis.spriteLocs = [\r\n\t\t\t{ name: \"sprite200\", x: 6, y: 10, width: 98, height: 82 },\r\n\t\t\t{ name: \"sprite201\", x: 132, y: 16, width: 74, height: 83 },\r\n\t\t\t{ name: \"sprite202\", x: 333, y: 21, width: 97, height: 78 },\r\n\t\t\t{ name: \"sprite203\", x: 220, y: 22, width: 105, height: 77 },\r\n\t\t\t{ name: \"sprite204\", x: 564, y: 27, width: 87, height: 52 },\r\n\t\t\t{ name: \"sprite205\", x: 454, y: 30, width: 92, height: 59 },\r\n\t\t\t{ name: \"sprite206\", x: 664, y: 62, width: 98, height: 36 },\r\n\t\t\t{ name: \"sprite207\", x: 17, y: 117, width: 82, height: 57 },\r\n\t\t];\r\n\r\n\t\tthis.spriteDict = {\r\n\t\t\trunning: [\r\n\t\t\t\t[6, 2],\r\n\t\t\t\t[9, 2],\r\n\t\t\t],\r\n\t\t\tknockedback: [[4], [7]],\r\n\t\t\tattacking: [[1], [4]],\r\n\t\t\twinning: [\r\n\t\t\t\t[4, 1],\r\n\t\t\t\t[7, 1],\r\n\t\t\t],\r\n\t\t};\r\n\r\n\t\tthis.frameCounter = 0;\r\n\t}\r\n\r\n\tdraw(ctx, dt) {\r\n\t\tthis.imageTimer += dt;\r\n\t\tctx.fillStyle = \"#f00\";\r\n\t\tctx.fillText(this.name, this.position.x - this.nameLength.width / 2 + 20, this.position.y + this.height + 20);\r\n\t\tthis.drawHealth(ctx);\r\n\t\tthis.drawAttackCD(ctx);\r\n\r\n\t\tswitch (this.status) {\r\n\t\t\tcase this.states.RUNNING:\r\n\t\t\t\tthis.drawSpriteRunning(ctx);\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.states.KNOCKBACKED:\r\n\t\t\t\tctx.fillText(\"KBed\", this.position.x, this.position.y - 10);\r\n\t\t\t\tthis.drawSpriteKBed(ctx);\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.states.ATTACKING:\r\n\t\t\t\tthis.drawSpriteAttacking(ctx);\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.states.WINNING:\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (this.imageTimer > this.imageTimerMax) {\r\n\t\t\tif (this.status == this.states.RUNNING || this.status == this.states.WINNING) {\r\n\t\t\t\tthis.col += 1;\r\n\t\t\t\tthis.imageTimer = 0;\r\n\t\t\t} else {\r\n\t\t\t\tthis.frameCounter += 1;\r\n\t\t\t\tthis.imageTimer = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tdrawSpriteAttacking(ctx) {\r\n\t\tlet sprite = this.getSpriteOneLoop(\"attacking\");\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.image1, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.image1, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\tdrawSpriteRunning(ctx) {\r\n\t\tlet sprite = this.getSpriteConstantLoop(\"running\");\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.image0, sprite.x, sprite.y, this.width, this.height, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(\r\n\t\t\t\tthis.image0,\r\n\t\t\t\tsprite.x,\r\n\t\t\t\tsprite.y,\r\n\t\t\t\tthis.width,\r\n\t\t\t\tthis.height,\r\n\t\t\t\t-this.position.x - this.width,\r\n\t\t\t\tthis.position.y,\r\n\t\t\t\tthis.width,\r\n\t\t\t\tthis.height\r\n\t\t\t);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\tdrawSpriteKBed(ctx) {\r\n\t\tlet sprite = this.getSpriteOneLoop(\"knockedback\");\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.image1, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.image1, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\tdrawSpriteWinning(ctx) {\r\n\t\tlet sprite = this.getSpriteKBed(\"winning\");\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.image0, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.image0, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\tasync loadFile(url) {\r\n\t\ttry {\r\n\t\t\tconst response = await fetch(url);\r\n\t\t\tconst data = await response.text();\r\n\t\t} catch (err) {\r\n\t\t\tconsole.error(err);\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/julian.js?");

/***/ }),

/***/ "./src/justin.js":
/*!***********************!*\
  !*** ./src/justin.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Justin)\n/* harmony export */ });\n/* harmony import */ var _character_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character.js */ \"./src/character.js\");\n\r\n\r\nclass Justin extends _character_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n\tconstructor(gameWidth, gameHeight, name, pos, image, id, assets, ctx) {\r\n\t\tsuper(gameWidth, gameHeight, name, pos, image, id, assets, ctx);\r\n\r\n\t\tthis.image = this.assets[0];\r\n\t\tthis.imageAttacking = this.assets[1];\r\n\r\n\t\t// custom column/row coords from sprite sheet\r\n\r\n\t\tthis.spriteDict = {\r\n\t\t\trunning: [\r\n\t\t\t\t[0, 2],\r\n\t\t\t\t[3, 2],\r\n\t\t\t],\r\n\t\t\tknockedback: [\r\n\t\t\t\t[0, 3],\r\n\t\t\t\t[5, 3],\r\n\t\t\t],\r\n\t\t\tattacking: [\r\n\t\t\t\t[0, 1],\r\n\t\t\t\t[7, 1],\r\n\t\t\t],\r\n\t\t\twinning: [\r\n\t\t\t\t[2, 4],\r\n\t\t\t\t[6, 4],\r\n\t\t\t],\r\n\t\t};\r\n\r\n\t\t// time needed for animation to attack\r\n\t\t// catches error if time is  < 0\r\n\t\tthis.timeforAttackAnimation =\r\n\t\t\t(this.attackCD - (this.spriteDict[\"attacking\"][1][0] - this.spriteDict[\"attacking\"][0][0]) * this.imageTimerMax) * 0.5;\r\n\t\tif (this.timeforAttackAnimation <= 0) {\r\n\t\t\tconsole.log(\"ERROR 0 for timeForAttackAnimation\");\r\n\t\t}\r\n\t}\r\n\r\n\t// custom drawing methods as they use different sprite sheets\r\n\tdrawSpriteAttacking(ctx) {\r\n\t\tlet sprite = this.getSpriteOneLoop(\"attacking\");\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.imageAttacking, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.imageAttacking, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\tdrawSpriteWinning(ctx) {\r\n\t\tlet sprite = this.getSpriteConstantLoop(\"winning\");\r\n\t\tctx.fillStyle = \"fuchsia\";\r\n\t\tctx.fillText(\"WINNER\", this.position.x + this.width / 2 - ctx.measureText(\"WINNER\").width / 2, this.position.y - 10);\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/justin.js?");

/***/ }),

/***/ "./src/woody.js":
/*!**********************!*\
  !*** ./src/woody.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Woody)\n/* harmony export */ });\n/* harmony import */ var _character_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character.js */ \"./src/character.js\");\n\r\n\r\nclass Woody extends _character_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n\tconstructor(gameWidth, gameHeight, name, pos, image, id, assets, ctx) {\r\n\t\tsuper(gameWidth, gameHeight, name, pos, image, id, assets, ctx);\r\n\r\n\t\tthis.image = this.assets[0];\r\n\t\tthis.imageWinning = this.assets[1];\r\n\r\n\t\t// custom column/row coords from sprite sheet\r\n\r\n\t\tthis.spriteDict = {\r\n\t\t\trunning: [\r\n\t\t\t\t[0, 2],\r\n\t\t\t\t[3, 2],\r\n\t\t\t],\r\n\t\t\tknockedback: [\r\n\t\t\t\t[0, 3],\r\n\t\t\t\t[5, 3],\r\n\t\t\t],\r\n\t\t\tattacking: [\r\n\t\t\t\t[0, 1],\r\n\t\t\t\t[3, 1],\r\n\t\t\t],\r\n\t\t\twinning: [\r\n\t\t\t\t[1, 3],\r\n\t\t\t\t[10, 3],\r\n\t\t\t],\r\n\t\t};\r\n\r\n\t\t// time needed for animation to attack\r\n\t\t// catches error if time is  < 0\r\n\t\tthis.timeforAttackAnimation =\r\n\t\t\t(this.attackCD - (this.spriteDict[\"attacking\"][1][0] - this.spriteDict[\"attacking\"][0][0]) * this.imageTimerMax) * 0.5;\r\n\t\tif (this.timeforAttackAnimation <= 0) {\r\n\t\t\tconsole.log(\"ERROR 0 for timeForAttackAnimation\");\r\n\t\t}\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/woody.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;